all java flle have .java extesion
jvm is required to run any java code 
when compiling .java so after compilation .class file is generated by compiler
javac is a compiler, it works along with jdk(java development kit) latest version is 1.8(is used to convert java code to byte code)
exact java code cannot be retrived from the byto code(.class file) but we can retrieve the structure of the class by using javap <.class file>	
jvm is installed by default on windows and linux
jre is java run time environment

System is a class
out is object
print is method

jvm accepts a main method so we have to create a main method
void is added to implement method without any return
methods are of two types static and non static
static belongs to class
non static belongs to object
pubic to specify we can access from anywhere

class name is generally filename by convention but not necesary need not be strictly followed
Public class should have same name as filename
javac <filename> to compile
java <classname>

program should have logical code inside main method and main method sohuld belong to class

by default all decimal values are double in java

to assign float values
float num1 = 6.1f;		 

ide is where we can compile and run code at same place
eg 
eclipse, netbeans, jedit

ternary operator assigns higher datatype to the variables in code eg:
obj = if true ? new Integer(10):new Double(15.0)
obj = 10.0 (not 10)

calucation
Factors from 1 till n/2
prime number check from  till sqrt(n)

n = a*b if factor exists
now sqrt(n)*sqrt(n)=n
it means one is greater than sqrt(n) and one is less than sqrt(n)
so check till sqrt(n) if it is prime you will get atleast a factor till there

for swaping values of two numbers
a = a^b;
b = a^b;
a = a^b;
b = a+b-(a=b);

int a[] = new int[5]; # in java

binary representation int i = 0B101;
system.out.println(i); //prints 5

Two dimensional array and enhanced for loop:

int p[][] = { {1,2},{3,4}};
for(int i[] : p)
{
	for(int j : i)
	{
	system.out.println(j);
	}
}

jagged array when the length of the two dimensional array is different

To pass variable number of arguements

public class example
{
	public static void main(String[] args)
	{
		Display obj = new display();
		obj.show(4,5,6);
	}
}

class display
(
	public void show(int ... a)  // Varargs - variable arguements
	{
		for(int i : a)
		{
			system.out.println(i);
		}
	}
)

to create instance in java

class A
{
	int x;
	public void show
	{
			System.out.printlm("HII");
	}
}

A obj = new A(); // A obj is reference and A() is a contructor

65 video

in java passing is always by value in hash code format

package <package name> is used to declare package name
lets say e declared package A and created a class B
to import we will write import A.B
same package cannot have two files(classes) with same name
if we want to access a class outside the package it must be public class

in java we have acces modifiers(default,final,public,private,protected) rather than access specifiers as in c++
if modifer is not specified it is default modifier
default moifer is not accessible outside the class

Private:Specific class
Default:Specific package
Public:Any class or package
Protected:Subsiding class(if class A has protected int variable i then only class B which inherits class A can access that variable)


static methods dont need a instance of class to be called. they can be directly called from classname
Non static member can be used inside a static method inside a class
We can use a static variable inside non static method but cannot use non static variable inside a static method

To count the number of instance of a class created use class variable(keyword static)

class A
{
	static int i;
	public A()
	{
		i++;
	}
	public void count()
	{
		System.out.println("The number of instance of class created is"+i);
	}
}

A obj = new A();
obj.count();

Static block is a block which is executed when a class is loaded in the JVM i.e. before wven calling the main method static block will be executed first

we can have multiple tatic blocks and they will be loaded in sequence by jvm

75 to be done

Object copy(instance copy) is of three types:
Shallow copy 1 oject 2 reference 
Deep copy 2 object 2 reference copied manually
Cloning clone

if we create this way:
A obj = new A()
obj.i = 5;
obj.j = 6;
A obj1 = obj;
then 2 reference are created in stack memory but they both pint to same object in the heap memory

A obj = new A()
obj.i = 5;
obj.j = 6;
A obj1 = new A();
obj1.i = 5;
obj1.j = 6;

A obj1 = obj.clone();


OOPS oops starts here

Encapsulation says that to change the vlue of a variable method should be used(declar variable private)

class A
{
	private int i;

	public void setI(int j)
	{
		i = j;
	}
	public int getI();
	{
		return i;
	}
}
 
A obj = new A();
obj.setI(5);
system.out.println(obj.getI());

Inheritance means extending one class to have additional members than the parent class
class <child class> extends <parent class>

class A()
{
	public void show()
	{

	}
	public void show(int i)
	{

	}
}

A obj = new A();
obj.show(),obj.show(5) will call two different methos with same name tihs is called polymorphism(poly-many,morph-behaviour)
this is called Method overloading
same way we can implement constructor overloading

class A
{
	public void show()
	{

	}
}

class B extends A
{
	public void show()
	{

	}
}
B obj = new B();
obj.show() this call show inside class B not class A's show. this is called method overriding
final keyword can be added in front of show in class A to make it unoverridable

every construtor calls a super constructor i.e. parent contrutor's contructor is called always(even if we dont explicitly write super it is always caleed)



class A
{
	public A()
	{
		system.out.print("fgfsf")
	}
}

class B extends A
{
	public B()
	{
		system.out.print("fgf")
	}
}

//fgfsf is printed first then fgf is printed 

super keyword as a method is used to call cnstructor of parent class
final variable is used to fix value of a variable like static in c++, once assigned it wont change
A class can be made which cannot be inherited by adding keyword final

class A
{
	private int x;
	public A(int x)
	{
		x = x;  //this will set local variable itelf so intance variable willl not be set hence we use this like this.x = x;
	}
}


variables are of three types
class A
{
	int i;//instance variabe
	public void fun(int i //local variable)
	{
		i++;
	}
}
and class variable

Anonymous object:
new A().fun() 
it has advantage  that it does not consume any memory inside stack
also it will be available for garbage collection

Abstraction means taking only important stuff of a particular thing
abstract class phone
{
	abstract public void call()
	{

	}
	abstract public void camera()
	{

	}
}

class iphone A extends phone
{
	public void csll()
	{

	}
	public vid canera()
	{

	}
}


class samsung  extends phone
{
	public void csll()
	{

	}
	public vid canera()
	{

	}
}
 class repair()
 {
 public repair(phone p) // advatange of abstraction is that here we can just write phone class otherwise we had to write class name specifically for each class
 {

 }
 }
 if class is abtract methods may not be abstract but if a method is abstract class has to be abstract
 public abtract void login(); thi is a abstract method
 abtract class cannot have have an object of its own 

 Every class which is inheriting an abstract class must imlement the abstract methods which were defined in abstract class otherwise the child class will also become abstract

 Java does not support multi inheritance
 So to get multiple inheritance we have interfaces;

 Class can can & define methods whreas interface can only declare methods g
 astract class A
 {
 	public abstract A()
 	{

 	}
 	public void B()
 	{

 	}
 }

 interface B
 {
 	public void show();
 }
 class C implemets B;
 {

 } //this class will define all methods of B


 interface B
 {
 	public void show();
 }
 class C implemets B;
 {
 	public void show()
 	{
 	//defination
 	}
 	public void display()
 	{
 	//defination
 	}
 }

 so lets say we only what user to use show method and not display method then 
 A obj = new B(); //alothough we cant create object of interface but we can creat its reference and assign it to clas C's object,
 obj.show();
 obj.display; //throws error

Every method in intrface is by default public abtract

 so Interface has two main advantage:
 !. allows to create multiple inheritance
 2. adds security

Interfaces are of three types:
1. Marker interface
2. Single Interface
3. Normal inerface

we can define a method in an interface if default keyword is used in java 8 i.e. jdk 1.8

default has low priority than class methods

instanceof keyword is used to check if object is instance of any class

to take inut from user program
import java.util.scanner;

public class stringops
{
	public static void main(String[] args)
	{
		String s1,s2;
		Scanner sc = new Scanner(System.in);
		Systemoutprintln("Enter two numbers");
		s1 = sc.nextLine();
		s2 = sc.nextLine();
		String s3 = s1.concat(s2); //s1+s2 can also be done
		System.out.println("Concatination result : "+s3);
		int l1 = s1.length();
		int l2 = s2.length();
		s3 = s2.toUppercase();
	}
}

Every class injav extends an object class

in system.out.println out is an object of system class

System.in.read() is for tsking input
biggest drawback is it can only take one character at a time

public class stringops
{
	public static void main(String[] args)
	{
		String str = "";
		int i =0;
		Scaneer sc = new Scanner(System.in);
		str = Integer.parseInt(sc.nextLine());//can use sc.nextInt();
		System.out.println("I is : "+i);
	}
}

C is POP procedure oriented language
C++ is partitialy objec oriented
Java is 99.99% oject oriented only due to primitive data types it is not completely object oriened e.g. int i;

strings are immutable in java

Error are of three type:
Syntax error
Logical Error
Runtime Error // like 2+2 is giving o/p 5

Syntax Error(Compliation Error) and Logical error can be hadled by testing but runtime error is faed at user end

Critical statement should always be enclosed in try catch block

simplest way to catch any excption

try{
	k = i/j;
}
catch(Exception e)
(
	System.out.println(e);
)
finally
{
	System.out.println("Run this block always") //this block runs always 
}

throws is added after a class to supress the exception but not to catch it 

throw new <exceptionname>(): is ued t throw exception

In C++ all exceptions are unchecked, it is al upto user to handle them

In Java there are two types of exception (complier forces you to handle the exception, is called checked exception)

1. Checked Exception(Exception which are checked during compile time and  the program will give error to handle them, they can be handled via throws or try catch)
2. Unchecked Exception(Compiler will allow to compile it but it will throw error if the exection failes like division by zero. )


// Java program to demonstrate working of throws 
class ThrowsExecp 
{ 
    static void fun() throws IllegalAccessException 
    { 
        System.out.println("Inside fun(). "); 
        throw new IllegalAccessException("demo"); 
    } 
    public static void main(String args[]) 
    { 
        try
        { 
            fun(); 
        } 
        catch(IllegalAccessException e) 
        { 
            System.out.println("caught in main."); 
        } 
    } 
} 

throws keyword is required only to convince compiler and usage of throws keyword does not prevent abnormal termination of program.

Program to demonstarte file handling in java:
 
import java.io.*

public class  FileDemo
{
	public static void main(String[] args) throws Exception
	{

		File f = new File("demo.txt");

		FileOutputStream fos = new FileOutputStream(f);
		DataOutputStream dos = new DataOutputStream(fos);
		dos.writeUTF("demo class");

		FileInputStream fis = new FileInputStream(f);
		DataInputStream dis = new DataInpuStream(fis);
		Srinng str = dis.readUTF();
		System.out.println(str);
	}
}

Properties file is a key value pair file created through java, it iss generally used to store the config in a file. EG:

import jaa.util.*

public class App
{
	public tatic void main(String[] args) throws Exception
	{
		Properties p = new Properties();
		OutputSteam os = new FileOutputStream("Data_Config.properties");

		p.setProperty("url","localhost:3306/myDB");
		p.setProperty("uname","kishan");
		p.setProperty("pass","pwfesg");

		p.store(os,null);

		InputStrean is = new FileInputStream("Data_Config.properties")
		p.load(is);
		system.out.println(p.getProperty("unmae")); //output will be kishan
	}
}

